#version 330 core

// Input vertex data, different for all executions of this shader
in vec3 vertexPosition;			// modelspace
in vec3 vertexNormal;
in vec2 vertexUV;

// Values that stay constant for the whole mesh
uniform mat4 projectionMatrix;	// camera projection
uniform mat4 viewMatrix;		// camera matrix
uniform mat4 modelMatrix;		// model matrix
uniform mat4 modelViewMatrix;	// view * model matrix
uniform mat3 normalMatrix;		// model-view normal

#define MAX_LIGHTS 10
uniform int lightCount;
uniform vec3 lightPosition[MAX_LIGHTS];	// worldspace
uniform vec3 lightDiffuse[MAX_LIGHTS];
uniform float lightPower[MAX_LIGHTS];

uniform vec3 ambientColor;				// indirect light

// Output data, will be interpolated for each fragment
 out vec3 lightColor;
out vec2 UV;

vec3 adsShading(vec4 position, vec3 norm, int idx) {
	vec4 lightPosCam = viewMatrix * vec4(lightPosition[idx], 1.0); // cameraspace
	vec3 lightDir = normalize(vec3(lightPosCam - position));
	vec3 viewDir = normalize(-position.xyz);
	vec3 reflectDir = reflect(-lightDir, norm);
	float distance = length(lightPosition[idx] - (modelMatrix * vec4(vertexPosition,1)).xyz);

	// ambient, simulates indirect lighting
	vec3 amb = ambientColor * vec3(0.1, 0.1, 0.1);

	// diffuse, direct lightning
	float cosTheta = clamp(dot(norm, lightDir), 0.0, 1.0);
	vec3 diff = lightDiffuse[idx] * lightPower[idx] * cosTheta / (distance * distance);

	// specular, reflective highlight, like a mirror
	float cosAlpha = clamp(dot(viewDir, reflectDir), 0.0, 1.0);
	vec3 spec = vec3(0.3, 0.3, 0.3) * lightDiffuse[idx] * lightPower[idx] * pow(cosAlpha, 5.0) / (distance * distance);

	return amb + diff + spec;
}

void main() {
	// Get the position and normal in camera space
	//vec3 camNorm = normalize(normalMatrix * vertexNormal);
	vec3 camNorm = normalize((viewMatrix * modelMatrix * vec4(vertexNormal, 0.0)).xyz);
	vec4 camPosition = modelViewMatrix * vec4(vertexPosition, 1.0);
	
	// Evaluate the lighting equation
	lightColor = vec3(0.0);
	for (int idx = 0; idx < lightCount; idx++) {
		lightColor += adsShading(camPosition, camNorm, idx);
	}
	
	UV = vertexUV;

	// Output position of the vertex, clipspace
	gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPosition, 1.0);
}
